# -*- coding: utf-8 -*-
"""
author: UnicornOnAzur

This module demonstrates creating a map of France in GeoPandas, Plotly and
Folium, and scaling the map either by bounds or by a predetermined center
and zoom level.
"""
# Standard library
import functools
import io
import json
import typing
# Third party
import folium
import geopandas as gpd
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import PIL.ImageFile
import plotly.express as px
import plotly.graph_objects as go
import requests
# Local imports
import geo_tools
# Constants
DATA_FOLDER: str = "data/"
OUTPUT_FOLDER: str = "output/"
GEOJSON_FILENAME: str = f"{DATA_FOLDER}france.geojson"
GEOJSON_URL: str =\
    "https://france-geojson.gregoiredavid.fr/repo/departements.geojson"
GREY_COLOR: str = "darkgrey"
ORANGE_COLOR: str = "orange"
DEPARTMENT: str = "Haute-Marne"


def load_data() -> typing.Tuple[bytes, typing.Dict, gpd.GeoDataFrame]:
    """
    This function fetches the GeoJSON data, parses it into a dictionary,
    and loads it into a GeoDataFrame for further analysis.

    Parameters:
        None

    Returns:
        A tuple containing the raw bytes of the GeoJSON, the parsed GeoJSON
    dictionary, and the GeoDataFrame.
    """
    geojson_bytes: bytes = fetch_geojson()
    geojson_dict: typing.Dict = json.loads(geojson_bytes)
    gdf: gpd.GeoDataFrame = gpd.read_file(GEOJSON_FILENAME)
    return geojson_bytes, geojson_dict, gdf


def fetch_geojson() -> bytes:
    """
    Fetches GeoJSON data from a file or a URL. When the needed file does not
    exist yet, it is retrieved from the URL.

    Parameters:
        None

    Returns:
        The raw bytes of the GeoJSON
    """
    try:
        with open(GEOJSON_FILENAME, "rb") as file:
            geojson_bytes: bytes = file.read()
    except FileNotFoundError:
        print("Retrieving data from the website...")
        response: requests.Response = requests.get(GEOJSON_URL)
        response.raise_for_status()
        geojson_bytes: bytes = response.content
        with open(GEOJSON_FILENAME, "wb") as file:
            file.write(geojson_bytes)
    return geojson_bytes


def create_center_points(
    geojson_bytes: bytes
        ) -> gpd.GeoDataFrame:
    """
    Create a GeoDataFrame containing the centroid, median, and mean points
    from the provided GeoJSON bytes.

    Parameters:
        geojson_bytes : the raw bytes of the GeoJSON.

    Returns:
        A GeoDataFrame with the calculated center points.
    """
    return gpd.GeoDataFrame(
        (df := pd.DataFrame(
            [geo_tools.get_centroid(geojson_bytes) | {"name": "centroid"},
             geo_tools.get_median(GEOJSON_FILENAME) | {"name": "median"},
             geo_tools.get_mean(GEOJSON_FILENAME) | {"name": "mean"}])),
        geometry=gpd.points_from_xy(df["lon"],
                                    df["lat"]),
        crs="EPSG:4326")


def plotly_customizer(
    func: typing.Callable[..., go.Figure]
        ) -> typing.Callable[..., go.Figure]:
    """
    A decorator to customize Plotly figures by updating layout properties.

    Parameters:
        func : A function that returns a Plotly Figure.

    Returns:
        A wrapper function that applies layout customizations to the figure.
    """
    @functools.wraps(func)
    def wrapper(
        *args: typing.Any
            ) -> go.Figure:
        """
        Wrapper function that applies layout customizations to the figure.

        Parameters:
            *args : Positional arguments to be passed to the original function.

        Returns:
            A Plotly Figure with updated layout properties.
        """
        fig = func(*args)
        fig.update_layout(showlegend=False,
                          margin={"l": 0, "r": 0, "t": 0, "b": 0},
                          width=700,
                          height=700)
        return fig
    return wrapper


def add_geojson_layer(
    func: typing.Callable[..., go.Figure]
        ) -> typing.Callable[..., go.Figure]:
    """
    A decorator that adds a GeoJSON layer to a figure.

    Paramters:
        func : The function that generates the figure.

    Returns:
        A wrapper function that adds the GeoJSON layer to the figure.
    """
    @functools.wraps(func)
    def wrapper(
        *args: typing.Any
            ) -> go.Figure:
        """
        Wrapper function that adds a GeoJSON layer to the figure generated by
        the decorated function.

        Parameters:
            *args: Positional arguments passed to the original function.

        Returns:
            The figure with the GeoJSON layer added.
        """
        figure: go.Figure = func(*args)
        with open(GEOJSON_FILENAME) as geojson_file:
            geojson_data = json.load(geojson_file)
        figure.update_layout(
            map_layers=[{"below": "traces",
                         "type": "fill",
                         "color": ORANGE_COLOR
                                  if feature["properties"]["nom"] == DEPARTMENT
                                  else GREY_COLOR,
                         "source": feature}
                        for feature in geojson_data["features"]])
        return figure
    return wrapper


def save_plotly(
    func: typing.Callable[..., go.Figure]
        ) -> typing.Callable[..., go.Figure]:
    """
    A decorator that saves the output of a Plotly figure as a PNG file.

    Parameters:
        func : The function that generates a Plotly figure.

    Returns:
        The wrapper function that saves the figure as a PNG file.
    """
    @functools.wraps(func)
    def wrapper(
        *args: typing.Any
            ) -> go.Figure:
        """
        Wrapper function that calls the original function and saves the figure.

        Parameters:
            *args: Positional arguments to pass to the original function.

        Returns:
            The Plotly figure generated by the original function.
        """
        fig: go.Figure = func(*args)
        with open(f"{OUTPUT_FOLDER}{func.__name__}.png", "wb") as file:
            file.write(fig.to_image("png"))
    return wrapper


def get_zoom_scale(
    plot: str,
    bounds: typing.List[float]
        ) -> int:
    """
    Calculate the zoom level for a given plot type based on the area defined
    by bounds.

    https://docs.mapbox.com/help/glossary/zoom-level/

    Parameters:
        plot : The type of plot ('plotly' or 'folium').
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        The zoom level, constrained to the appropriate range for the specified
    plot type.
    """
    xmin, ymin, xmax, ymax = bounds
    area: float = (xmax - xmin) * (ymax - ymin)

    if plot == "plotly":
        # Zoom level between 0 and 20.
        area_sizes = [0, 5*10**-7, 5*10**-5, 1.5*10**-2, 150, (180 * 360)]
        zoom_level = [20, 17.5, 14, 10, 5, 0]
    elif plot == "folium":
        # Zoom level between 0 and 18.
        area_sizes = [0, 10**-5, 10**-4, 10**-2, 150, (180 * 360)]
        zoom_level = [20, 17, 14, 12, 6, 0]

    zoom: int = int(np.interp(area,
                              xp=area_sizes,
                              fp=zoom_level))
    return zoom


def folium_style_function() -> typing.Callable[[typing.Dict[str, typing.Any]],
                                               typing.Dict[str, typing.Any]]:
    """
    Returns a style function for folium features based on their properties.

    The style function determines the fill color based on the 'nom' property
    of the feature. If the 'nom' matches the DEPARTMENT, it uses ORANGE_COLOR;
    otherwise, it uses GREY_COLOR. The fill opacity, border color, and weight
    are also defined.

    Parameters:
        None

    Returns:
        A function that takes a feature dictionary and returns a style
        dictionary.
    """
    return lambda feature: {
                       "fillColor": ORANGE_COLOR
                       if feature["properties"]["nom"] == DEPARTMENT
                       else GREY_COLOR,
                       "fillOpacity": 1,
                       "color": "black",
                       "weight": 1
                   }


def save_folium(
    filename: str
        ) -> typing.Callable[[typing.Callable[..., typing.Any]],
                             typing.Callable[..., None]]:
    """
    Decorator to save the output of a folium map as a PNG image.

    Parameters:
        filename : The name of the file where the image will be saved.

    Returns:
        A decorator that wraps a function returning a folium map.
    """
    def decorator(
        func: typing.Callable[..., typing.Any]
            ) -> typing.Callable[..., None]:
        """
        Decorator function that wraps the original function.

        Parameters:
            func : The function to be wrapped.

        Returns:
            The wrapper function that saves the image.
        """
        @functools.wraps(func)
        def wrapper(
            *args: typing.Any
                ) -> None:
            """
            Wrapper function that executes the original function and saves the
            image.

            Parameters:
                *args : Positional arguments passed to the original function.

            Returns:
                This function does not return a value.
            """
            img_data: bytes = func(*args)._to_png()
            img: PIL.PngImagePlugin.PngImageFile =\
                PIL.Image.open(io.BytesIO(img_data))
            img.save(f"{OUTPUT_FOLDER}{filename}")
        return wrapper
    return decorator


def geopandas_fit_to_bounds(
    gdf: gpd.GeoDataFrame
        ) -> None:
    """
    This function creates a plot of a GeoDataFrame, highlighting a specific
    region and adjusting the view to center and zoom in on that region.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.

    Returns:
        None
    """
    # Create a figure and axis for plotting
    figure, ax = plt.subplots(figsize=(7, 7))

    # Define colors based on the region name
    colors: typing.List[str] = [ORANGE_COLOR
                                if nom == DEPARTMENT else GREY_COLOR
                                for nom in gdf["nom"]]

    # Plot and save the default view
    gdf.plot(kind="geo",  # Explicitly defining kind of plot
             color=colors,
             ax=ax)
    figure.subplots_adjust(**{"left": 0.05, "right": 1,
                              "top": .935, "bottom": .05,
                              "wspace": 0, "hspace": 0})
    figure.savefig(f"{OUTPUT_FOLDER}geopandas_default.png")

    # Get the bounds of the specified region, adjust the plot and save
    xmin, ymin, xmax, ymax = gdf.loc[gdf["nom"] == DEPARTMENT].total_bounds
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    figure.savefig(f"{OUTPUT_FOLDER}geopandas_fit_to_bounds.png")


@plotly_customizer
@add_geojson_layer
def _create_plotly_scattermap(
    center: typing.Dict = None,
    zoom: int = None
        ) -> go.Figure:
    """
    Create a Plotly scatter map with center and zoom parameters.

    Parameters:
        center : Center coordinates for the map.
        zoom : Zoom level for the map.

    Returns:
       A Plotly figure object representing the scatter map.
    """
    return px.scatter_map(lat=[], lon=[], zoom=zoom, center=center)


@plotly_customizer
@add_geojson_layer
def _create_plotly_linemap(
    zoom: int = None,
    center: typing.List[float] = None
        ) -> go.Figure:
    """
    Create a Plotly line map with center and zoom parameters.

    Parameters:
        center : Center coordinates for the map.
        zoom : Zoom level for the map.

    Returns:
        A Plotly figure object representing the line map.
    """
    return px.line_map(lat=[], lon=[], zoom=zoom, center=center)


@plotly_customizer
def _create_plotly_choroplethmap(
    gdf: gpd.GeoDataFrame,
    data: typing.Dict,
    center: typing.Dict = None,
    zoom: int = None
        ) -> go.Figure:
    """
    Create a Plotly choropleth map with center and zoom parameters.

    Parameters:
        gdf : A GeoDataFrame containing geographical data.
        data : A dictionary containing geojson data for the choropleth.
        center : Center coordinates for the map.
        zoom : Zoom level for the map.

    Returns:
        A Plotly figure object representing the choropleth map.
    """
    colormap: typing.Dict = {k: ORANGE_COLOR if k == DEPARTMENT
                             else GREY_COLOR for k in gdf["nom"].values}
    figure: go.Figure = px.choropleth_map(
        data_frame=gdf,
        geojson=data,
        featureidkey="properties.nom",
        locations="nom",
        color="nom",
        color_discrete_map=colormap,
        zoom=zoom,
        center=center)
    return figure


@plotly_customizer
@add_geojson_layer
def _create_plotly_densitymap(
    zoom: int = None,
    center: typing.Dict = None
        ) -> go.Figure:
    """
    Create a Plotly density map with center and zoom parameters.

    Parameters:
        center : Center coordinates for the map.
        zoom : Zoom level for the map.

    Returns:
        A Plotly figure object representing the density map.
    """
    return px.density_map(lat=[], lon=[], zoom=zoom, center=center)


@plotly_customizer
def _create_plotly_choropleth(
    gdf: gpd.GeoDataFrame,
    data: typing.Dict,
    fitbounds: str
        ) -> go.Figure:
    """
    Create a Plotly choropleth map with fitbounds parameter.

    Parameters:
        gdf : A GeoDataFrame containing geographical data.
        data : A dictionary containing geojson data for the choropleth.
        fitbounds : Setting for auto-fill, one of [False|"locations"|"geojson"]

    Returns:
        A Plotly figure object representing the choropleth map.
    """
    colormap: typing.Dict = {k: ORANGE_COLOR if k == DEPARTMENT
                             else GREY_COLOR for k in gdf["nom"].values}
    figure: go.Figure = px.choropleth(
        data_frame=gdf,
        geojson=data,
        featureidkey="properties.nom",
        locations="nom",
        color="nom",
        color_discrete_map=colormap,
        projection="mercator",
        basemap_visible=False
        )
    figure.update_geos(fitbounds=fitbounds)
    return figure


@plotly_customizer
def _create_plotly_scattergeo(
    gdf: gpd.GeoDataFrame,
    data: typing.Dict,
    fitbounds: str
        ) -> go.Figure:
    """
    Create a Plotly scatter geo map with fitbounds parameter.

    Parameters:
        gdf : A GeoDataFrame containing geographical data.
        data : A dictionary containing geojson data for the choropleth.
        fitbounds : Setting for auto-fill, one of [False|"locations"|"geojson"]

    Returns:
        A Plotly figure object representing the scatter geo map.
    """
    colormap: typing.Dict = {k: GREY_COLOR for k in gdf["nom"].values}
    figure: go.Figure = px.scatter_geo(
        data_frame=gdf,
        geojson=data,
        featureidkey="properties.nom",
        locations="nom",
        color="nom",
        color_discrete_map=colormap,
        projection="mercator",
        basemap_visible=False
        )
    figure.update_geos(fitbounds=fitbounds)
    return figure


@plotly_customizer
def _create_plotly_linegeo(
    gdf: gpd.GeoDataFrame,
    data: typing.Dict,
    fitbounds: str
        ) -> go.Figure:
    """
    Create a Plotly line geo map with with fitbounds parameter.

    Parameters:
        gdf : A GeoDataFrame containing geographical data.
        data : A dictionary containing geojson data for the choropleth.
        fitbounds : Setting for auto-fill, one of [False|"locations"|"geojson"]

    Returns:
        A Plotly figure object representing the line geo map.
    """
    colormap: typing.Dict = {k: GREY_COLOR for k in gdf["nom"].values}
    figure: go.Figure = px.line_geo(
        data_frame=gdf,
        geojson=data,
        featureidkey="properties.nom",
        locations="nom",
        color="nom",
        color_discrete_map=colormap,
        projection="mercator",
        basemap_visible=False
        )
    figure.update_geos(fitbounds=fitbounds)
    return figure


@save_plotly
def plotly_scattermap_center_and_zoom(
    geojson_bytes: bytes,
    bounds: typing.List[float]
        ) -> None:
    """
    Generate a Plotly scatter map with center and zoom and save it as an image.

    Parameters:
        geojson_bytes : the raw bytes of the GeoJSON
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    center: typing.Dict = geo_tools.get_centroid(geojson_bytes)
    zoom: int = get_zoom_scale("plotly", bounds)
    return _create_plotly_scattermap(center, zoom)


@save_plotly
def plotly_scattermap_bounds(bounds):
    """
    Generate a Plotly scatter map fit to bounds and save it as an image.

    Parameters:
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    xmin, ymin, xmax, ymax = bounds
    fig = _create_plotly_scattermap()
    fig.update_layout({"map": {"bounds":
                               {"west": xmin,
                                "east": xmax,
                                "south": ymin,
                                "north": ymax}
                               }
                       })
    return fig


@save_plotly
def plotly_linemap_center_and_zoom(geojson_bytes, bounds):
    """
    Generate a Plotly line map with center and zoom and save it as an image.

    Parameters:
        geojson_bytes : the raw bytes of the GeoJSON
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    center: typing.Dict = geo_tools.get_centroid(geojson_bytes)
    zoom: int = get_zoom_scale("plotly", bounds)
    return _create_plotly_linemap(zoom, center)


@save_plotly
def plotly_linemap_bounds(bounds):
    """
    Generate a Plotly line map fit to bounds and save it as an image.

    Parameters:
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    xmin, ymin, xmax, ymax = bounds
    fig = _create_plotly_linemap()
    fig.update_layout({"map": {"bounds":
                               {"west": xmin,
                                "east": xmax,
                                "south": ymin,
                                "north": ymax}
                               }
                       })
    return fig


@save_plotly
def plotly_choroplethmap_center_and_zoom(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict,
    geojson_bytes: bytes,
    bounds: typing.List[float]
        ) -> None:
    """
    Generate a choropleth map with center and zoom and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.
        geojson_bytes : the raw bytes of the GeoJSON.
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    center: typing.Dict = geo_tools.get_centroid(geojson_bytes)
    zoom: int = get_zoom_scale("plotly", bounds)
    return _create_plotly_choroplethmap(gdf, geojson_, center, zoom)


@save_plotly
def plotly_choroplethmap_bounds(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict,
    bounds
        ) -> None:
    """
    Generate a Plotly density map fit to bounds and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    xmin, ymin, xmax, ymax = bounds
    fig = _create_plotly_choroplethmap(gdf, geojson_)
    fig.update_layout({"map": {"bounds":
                               {"west": xmin,
                                "east": xmax,
                                "south": ymin,
                                "north": ymax}
                               }
                       })
    return fig


@save_plotly
def plotly_densitymap_center_and_zoom(geojson_bytes, bounds):
    """
    Generate a Plotly density map with center and zoom and save it as an image.

    Parameters:
        geojson_bytes : the raw bytes of the GeoJSON
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    center: typing.Dict = geo_tools.get_centroid(geojson_bytes)
    zoom: int = get_zoom_scale("plotly", bounds)
    return _create_plotly_densitymap(zoom, center)


@save_plotly
def plotly_densitymap_bounds(bounds):
    """
    Generate a Plotly density map fit to bounds and save it as an image.

    Parameters:
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        None
    """
    xmin, ymin, xmax, ymax = bounds
    fig = _create_plotly_densitymap()
    fig.update_layout({"map": {"bounds":
                               {"west": xmin,
                                "east": xmax,
                                "south": ymin,
                                "north": ymax}
                               }
                       })
    return fig


@save_plotly
def plotly_choropleth_bound_geojson(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a choropleth map fitted to the GeoJSON and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    return _create_plotly_choropleth(gdf, geojson_, "geojson")


@save_plotly
def plotly_choropleth_bound_locations(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a choropleth map fitted to the locations and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    subset = gdf.loc[gdf["nom"] == DEPARTMENT]
    return _create_plotly_choropleth(subset, geojson_, "locations")


@save_plotly
def plotly_scattergeo_bound_geojson(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a scatter geo map fitted to the GeoJSON and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    return _create_plotly_scattergeo(gdf, geojson_, "geojson")


@save_plotly
def plotly_scattergeo_bound_locations(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a scatter geo map fitted to the locations and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    subset = gdf.loc[gdf["nom"] == DEPARTMENT]
    return _create_plotly_scattergeo(subset, geojson_, "locations")


@save_plotly
def plotly_linegeo_bound_geojson(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a line geo map fitted to the GeoJSON and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    return _create_plotly_linegeo(gdf, geojson_, "geojson")


@save_plotly
def plotly_linegeo_bound_locations(
    gdf: gpd.GeoDataFrame,
    geojson_: typing.Dict
        ) -> None:
    """
    Generate a line geo map fitted to the locations and save it as an image.

    Parameters:
        gdf : The GeoDataFrame containing geographical data.
        geojson_ : GeoJSON data.

    Returns:
        None
    """
    subset = gdf.loc[gdf["nom"] == DEPARTMENT]
    return _create_plotly_linegeo(subset, geojson_, "locations")


@save_folium("folium_zoom_and_center.png")
def folium_zoom_and_center(
    center: typing.Tuple,
    bounds: typing.List[float]
        ) -> folium.Map:
    """
    Create a Folium map centered at a specified location with a zoom level
    based on provided bounds.

    Parameters:
        center : The latitude and longitude to center the map.
        bounds : The geographical bounds to determine the zoom level.

    Returns:
        A Folium map object.
    """
    zoom = get_zoom_scale("folium", bounds)
    map_: folium.Map = folium.Map(location=center,
                                  width=700,
                                  height=700,
                                  zoom_start=zoom)
    folium.GeoJson(GEOJSON_FILENAME,
                   style_function=folium_style_function()).add_to(map_)
    return map_


@save_folium("folium_bounds.png")
def folium_fit_to_bounds(
    bounds: typing.List[float]
        ) -> folium.Map:
    """
    Creates a folium map that fits the specified geographical bounds.

    Parameters:
        bounds : A list containing the coordinates [xmin, ymin, xmax, ymax].

    Returns:
        A folium map object fitted to the specified bounds.
    """
    map_: folium.Map = folium.Map(width=700,
                                  height=700)
    folium.GeoJson(GEOJSON_FILENAME,
                   style_function=folium_style_function()).add_to(map_)
    xmin, ymin, xmax, ymax = bounds
    map_.fit_bounds([[ymin, xmin], [ymax, xmax]])
    return map_


@save_folium("folium_centerpoints.png")
def plot_center_points(
    centers: gpd.GeoDataFrame
        ) -> folium.Map:
    """
    Plots center points on a folium map with a legend.

    Parameters:
        centers : A DataFrame containing latitude, longitude, geometry and
        name of the center points.

    Returns:
        A folium map object with center points plotted.
    """
    def add_gridline(
        start: float,
        end: float,
        is_horizontal: bool
            ) -> None:
        """
        Adds gridlines to a folium map.

        Parameters:
            start : The starting coordinate for the gridline.
            end : The ending coordinate for the gridline.
            is_horizontal : If True, draws horizontal lines; if False, draws
            vertical lines.

        Returns:
            None
        """
        INTERVAL = 1 / 111  # 1 km to degrees, gives ~0.009
        for value in np.arange(start, end + 1, INTERVAL):
            coords: typing.List[typing.List[typing.Union[int, float]]] = (
                [[value, -180], [value, 180]] if is_horizontal
                else [[-90, value], [90, value]]
            )
            folium.PolyLine(coords,
                            **{"color": "black",
                               "weight": 0.5,
                               "opacity": 0.5}
                            ).add_to(map_)

    colors: typing.Dict[str, str] = {"centroid": "red",
                                     "median": "orange",
                                     "mean": "purple"}
    legend_html: str = (
        '<div style="position: fixed;'
        '\n\tbottom: 70px; left: 0px; width: 100px; height: 100px;'
        '\n\tborder:2px solid grey; z-index:9999; font-size:14px;'
        '\n\tbackground-color:white; opacity: 0.85;">'
        '\n\t&nbsp; <b>Legend</b> <br>'
                        )
    map_: folium.Map = folium.Map(width=700,
                                  height=700)
    for _, row in centers.iterrows():
        folium.Marker(location=[row["lat"], row["lon"]],
                      icon=folium.Icon(icon="star",
                                       color=colors[row["name"]])
                      ).add_to(map_)
        legend_html += (
            f'\n\t&nbsp; {row["name"]} &nbsp; <i class="fa fa-circle" '
            f'style="color:{colors[row["name"]]}"></i><br>'
        )
    legend_html += "\n</div>"
    map_.get_root().html.add_child(folium.Element(legend_html))
    xmin, ymin, xmax, ymax = centers.total_bounds
    map_.fit_bounds([[ymin, xmin], [ymax, xmax]])

    add_gridline(-90, 90, True)
    add_gridline(-180, 180, False)

    return map_


def main() -> None:
    """
    Main function to load data, create center points, determine bounds, and
    generate various plots.

    Parameters:
        None

    Returns:
        None
    """
    # Load data and create necessary variables
    geojson_bytes, geojson_data, gdf = load_data()
    center_points: gpd.GeoDataFrame = create_center_points(geojson_bytes)
    center: typing.Tuple[float] =\
        tuple(geo_tools.get_centroid(geojson_bytes).values())
    bounds: typing.List[float] = geo_tools.determine_bounds(GEOJSON_FILENAME)
    # Create GeoPandas plots
    geopandas_fit_to_bounds(gdf)
    # Create Plotly Geo plots
    plotly_scattermap_center_and_zoom(geojson_bytes, bounds)
    plotly_scattermap_bounds(bounds)
    plotly_linemap_center_and_zoom(geojson_bytes, bounds)
    plotly_linemap_bounds(bounds)
    plotly_choroplethmap_center_and_zoom(gdf, geojson_data, geojson_bytes, bounds)  # noqa: E501
    plotly_choroplethmap_bounds(gdf, geojson_data, bounds)
    plotly_densitymap_center_and_zoom(geojson_bytes, bounds)
    plotly_densitymap_bounds(bounds)
    # Create Plotly Mapbox Plots
    plotly_choropleth_bound_geojson(gdf, geojson_data)
    plotly_choropleth_bound_locations(gdf, geojson_data)
    plotly_scattergeo_bound_geojson(gdf, geojson_data)
    plotly_scattergeo_bound_locations(gdf, geojson_data)
    plotly_linegeo_bound_geojson(gdf, geojson_data)
    plotly_linegeo_bound_locations(gdf, geojson_data)
    # Create Folium plots
    folium_zoom_and_center(center, bounds)
    folium_fit_to_bounds(bounds)
    # Plot center points
    plot_center_points(center_points)


if __name__ == "__main__":
    main()
